---
title: Teleport Access Requests with Jira
description: How to set up the Teleport Jira plugin to notify users when another user requests elevated privileges.
---

This guide will explain how to setup Teleport with Jira. Teleport's Jira
integration allows you to treat Teleport access and permission requests using
Jira tickets.

{/* TODO: Edit this explanation if I need to after updating the rest of the
guide*/}

## Prerequisites

(!/docs/pages/includes/commercial-prereqs-tabs.mdx!)

- A Jira account with owner privileges that enable you to set up webhooks and
  workflows.

- An environment where you will run the Jira plugin. This is either:

  a. A Linux virtual machine with ports 80, 443, and 8081 open, plus a means of
  accessing the host (e.g., SSH with an open SSH port). 

  {/* TODO: Add advice to restrict 80 and 443 to Let's Encrypt and 8081 to Jira.
  Link to where to get the IP addresses for these services*/}

  b. A Kubernetes cluster.

- A registered domain name. We will use this to run a webhook that Jira will
  notify when your project changes.

(!/docs/pages/includes/tctl.mdx!)

## Step 1/9. Define RBAC resources

Before you set up the Jira plugin, you will need to enable Role Access Requests
in your Teleport cluster.

(!/docs/pages/includes/plugins/editor-request-rbac.mdx!)

## Step 2/9. Install the Teleport Jira plugin

<ScopedBlock scope={["enterprise", "oss"]}>

We recommend installing Teleport plugins on the same host as the Teleport Proxy
Service. This is an ideal location as plugins have a low memory footprint, and
will require both public internet access and Teleport Auth Service access. 

</ScopedBlock>
<ScopedBlock scope="cloud">

Install the Teleport Jira plugin on a host that can access both your Teleport
Cloud tenant and Jira.

</ScopedBlock>

<Tabs>
<TabItem label="Download">
  ```code
  $ curl -L -O https://get.gravitational.com/teleport-access-jira-v(=teleport.plugin.version=)-linux-amd64-bin.tar.gz
  $ tar -xzf teleport-access-jira-v(=teleport.plugin.version=)-linux-amd64-bin.tar.gz
  $ cd teleport-access-jira
  $ ./install
  ```
</TabItem>
<TabItem label="From Source">
  To install from source you need `git` and `go` installed. If you do not have Go installed, visit the Go [downloads page](https://go.dev/dl/).

  ```code
  # Checkout teleport-plugins
  $ git clone https://github.com/gravitational/teleport-plugins.git
  $ cd teleport-plugins/access/jira
  $ make
  ```
Run `./install` from `teleport-jira` or place the executable in `/usr/bin` or `/usr/local/bin` on the server installation.
</TabItem>
<TabItem label="Docker">
  ```code
  $ docker pull public.ecr.aws/gravitational/teleport-plugin-jira:(=teleport.plugin.version=)
  ```
</TabItem>
<TabItem label="Helm Chart">
  (!docs/pages/kubernetes-access/helm/includes/helm-repo-add.mdx!)
</TabItem>
</Tabs>

{/* TODO: Add instructions to verify that the installation works*/}

## Step 3/9. Fetch HTTPS credentials for the plugin

The Jira Access Request plugin serves a Jira webhook, an HTTP server that Jira
notifies wheen it updates your project. The plugin uses this webhook to listen
for changes in tasks that have to do with Access Requests and manage those
Access Requests in response.

Jira requires webhooks to use HTTPS (this also prevents third parties from
intercepting data about your Jira project and Teleport cluyster). To enable
HTTPS on your Jira plugin, we will fetch TLS credentials from Let's Encrypt. 

The technique you will use for fetching credentials depends on whether you are
running the plugin as an executable on a host (e.g., an EC2 instance) or on
Kubernetes.

<Notice type="warning">

The instructions in this section for managing TLS credentials are only for
illustrating how the plugin uses TLS credentials. Your organization probably
has its own system for managing TLS credentials, and that is the system you
should use in production.

</Notice>

So Jira can access the plugin, create a DNS A record that associates your domain
name with the IP address of the webhook.

<Tabs dropdownCaption="Environment type">
    <TabItem options="Executable" label="AWS Route 53">
    ```code
    # Tip for finding AWS zone id by the domain name.
    $ MYIP="$(curl https://ipv4.icanhazip.com/)"
    $ MYZONE_DNS="example.com"
    $ MYZONE=$(aws route53 list-hosted-zones-by-name --dns-name=${MYZONE_DNS?} | jq -r '.HostedZones[0].Id' | sed s_/hostedzone/__)

    # The fully qualified domain name for your Teleport Proxy Service.
    # These commands will also create an A record for a wildcard subdomain.
    $ MYDNS="tele.example.com"

    # Create a JSON file changeset for AWS.
    $ jq -n --arg ip ${MYIP?} --arg dns ${MYDNS?} '{"Comment": "Create records", "Changes": [{"Action": "CREATE","ResourceRecordSet": {"Name": $dns, "Type": "A", "TTL": 300, "ResourceRecords": [{ "Value": $ip}]}},{"Action": "CREATE", "ResourceRecordSet": {"Name": ("*." + $dns), "Type": "A", "TTL": 300, "ResourceRecords": [{ "Value": $ip}]}}]}' > myrecords.json

    # Review records before applying.
    $ cat myrecords.json | jq
    # Apply the records and capture change id
    $ CHANGEID=$(aws route53 change-resource-record-sets --hosted-zone-id ${MYZONE?} --change-batch file://myrecords.json | jq -r '.ChangeInfo.Id')

    # Verify that change has been applied
    $ aws route53 get-change --id ${CHANGEID?} | jq '.ChangeInfo.Status'
    # "INSYNC"
    ```
  </TabItem>
  <TabItem options="Executable" label="GCP Cloud DNS">
    ```code
    $ MYZONE="myzone"
    # The fully qualified domain name for your Teleport Proxy Service.
    # These commands will also create an A record for a wildcard subdomain.
    $ MYDNS="tele.example.com"
    $ MYIP="$(curl https://ipv4.icanhazip.com/)"

    $ gcloud dns record-sets transaction start --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction add ${MYIP?} --name="${MYDNS?}" --ttl="30" --type="A" --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction add ${MYIP?} --name="*.${MYDNS?}" --ttl="30" --type="A" --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction describe --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction execute --zone="${MYZONE?}"
    ```
  </TabItem>
  <TabItem options="Helm Chart" label="AWS Route 53 ">
    ```code
    $ MYIP=$(kubectl -n teleport get service teleport-jira-plugin -o jsonpath='{.status.loadBalancer.ingress[0].ip }')
    $ MYZONE_DNS="example.com"
    $ MYZONE=$(aws route53 list-hosted-zones-by-name --dns-name=${MYZONE_DNS?} | jq -r '.HostedZones[0].Id' | sed s_/hostedzone/__)

    # The fully qualified domain name for your Teleport Proxy Service.
    # These commands will also create an A record for a wildcard subdomain.
    $ MYDNS="tele.example.com"

    # Create a JSON file changeset for AWS.
    $ jq -n --arg ip ${MYIP?} --arg dns ${MYDNS?} '{"Comment": "Create records", "Changes": [{"Action": "CREATE","ResourceRecordSet": {"Name": $dns, "Type": "A", "TTL": 300, "ResourceRecords": [{ "Value": $ip}]}},{"Action": "CREATE", "ResourceRecordSet": {"Name": ("*." + $dns), "Type": "A", "TTL": 300, "ResourceRecords": [{ "Value": $ip}]}}]}' > myrecords.json

    # Review records before applying.
    $ cat myrecords.json | jq
    # Apply the records and capture change id
    $ CHANGEID=$(aws route53 change-resource-record-sets --hosted-zone-id ${MYZONE?} --change-batch file://myrecords.json | jq -r '.ChangeInfo.Id')

    # Verify that change has been applied
    $ aws route53 get-change --id ${CHANGEID?} | jq '.ChangeInfo.Status'
    # "INSYNC"
    ```
  </TabItem>
  <TabItem options="Helm Chart" label="GCP Cloud DNS ">
    ```code
    $ MYZONE="myzone"
    # The fully qualified domain name for your Teleport Proxy Service.
    # These commands will also create an A record for a wildcard subdomain.
    $ MYDNS="tele.example.com"
    $ MYIP=$(kubectl -n teleport get service teleport-jira-plugin -o jsonpath='{.status.loadBalancer.ingress[0].ip }')

    $ gcloud dns record-sets transaction start --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction add ${MYIP?} --name="${MYDNS?}" --ttl="30" --type="A" --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction add ${MYIP?} --name="*.${MYDNS?}" --ttl="30" --type="A" --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction describe --zone="${MYZONE?}"
    $ gcloud dns record-sets transaction execute --zone="${MYZONE?}"
    ```
  </TabItem>

</Tabs>

<Tabs>

<TabItem label="Executable">

We will use Caddy to run a webserver to communicate with Let's Encrypt and
manage TLS credentials.

First, install Caddy on the host where you will run the plugin. Follow the
instructions for your system in Caddy's [installation
guide](https://caddyserver.com/docs/install).

Create a directory called `teleport-jira`, which is where we will configure
Caddy to store TLS credentials.

Create a file called `Caddyfile` with the following content. Replace
`example.com` with the domain name you created earlier.

```text

storage file_system /var/teleport-jira

https://example.com {}

```

Run Caddy. Caddy will fetch credentials from Let's Encrypt automatically and
place them in `/var/teleport-jira`.

{/* TODO: use systemd or the `caddy start` command*/}

{/* TODO: Step to verify that this worked*/}

</TabItem>
<TabItem label="Helm Chart">

Use cert-manager to communicate with Let's Encrypt and generate a Kubernetes
secret containing TLS credentials that the pugin can use. 

If you do not have `cert-manager` already configured in the Kubernetes cluster
where you are installing Teleport, add the Jetstack Helm chart repository which
hosts the `cert-manager` chart, and install the chart:

```code
$ helm repo add jetstack https://charts.jetstack.io
$ helm repo update
$ helm install cert-manager jetstack/cert-manager \
--create-namespace \
--namespace cert-manager \
--set installCRDs=true
```

Install the NGINX ingress controller, which `cert-manager` will use to expose a
web server to Let's Encrypt:

```code
$ helm upgrade --install ingress-nginx ingress-nginx \
--repo https://kubernetes.github.io/ingress-nginx \
--namespace cert-manager
```

{/* TODO: Not sure if we need the `set
extraArgs="{--issuer-ambient-credentials}` line from the AWS Helm guide here*/}

Once `cert-manager` is installed, create and apply an `Issuer` resource that
configures `cert-manager` to fetch TLS credentials from Let's Encrypt. Create a
file called `issuer.yaml` with the following content:

```yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: letsencrypt-production
  namespace: teleport
spec:
  acme:
    email: email@address.com                                # Change this
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: letsencrypt-production
    solvers:
    - http01:
        ingress:
          class: nginx
```

`cert-manager` will create a new Kubernetes `Ingress` resource, and the `nginx`
controller will expose a web server that Let's Encrypt will use, via the
ACME-HTTP01 challenge, to prove that you have control over your domain name.

You'll need to replace `email@address.com` with an email address where you can
receive communications from Let's Encrypt.

After you have created the `Issuer` and updated the values, add it to your
cluster using `kubectl`:

```code
$ kubectl create namespace teleport
$ kubectl create -f issuer.yaml
```

{/* TODO: Step to verify that this worked*/}
</TabItem>
</Tabs>

## Step 4/9. Create a user and role for the plugin

(!docs/pages/includes/plugins/rbac.mdx!)

## Step 5/9. Export the access plugin identity

(!docs/pages/includes/plugins/identity-export.mdx!)

## Step 6/9. Set up a Jira project

{/* TODO: Make sure this section is still accurate*/}

### Create a permission management project

All new permission requests are going to show up in a project you choose. We
recommend that you create a separate project for permissions management, and a
new board in said project.

You'll need the project Jira key to configure the plugin.

### Set up a status board

Create a new board for tasks in the permission management project. The board has
to have at least these three columns:

1. Pending
2. Approved
3. Denied

Teleport's Jira plugin will create a new issue for each new permission request
in the first available column on the board. When you drag the request task to
the Approved column in Jira, the request will be approved. If you drag the
request task to the Denied column in Jira, the request will be denied.

### Set up a request ID field on Jira

The Teleport Jira plugin requires a custom issue field to be created.

Go to your Jira Project settings → Issue Types → Select type `Task` → add a new
Short Text field named `TeleportAccessRequestId`.

Teleport uses this field to reference its internal request ID. If anyone changes
this field on Jira, or tries to forge the permission request, Teleport will
validate it and ignore it.

### Retrieve your Jira API token

If you're using Jira Cloud, navigate to [Account Settings → Security → API
Tokens](https://id.atlassian.com/manage-profile/security/api-tokens) and create
a new app specific API token in your Jira installation. You'll need this token
later to configure the plugin.

For Jira Server, the URL of the API tokens page will be different depending on
your installation.

### Set up a Jira webhook

Go to Settings → General → System → Webhooks and create a new webhook for Jira
to tell the Teleport plugin about updates.

For the webhook URL, use the URL you created a DNS record for earlier in this
guide.

The webhook needs to be notified only about new issues being created, issues
being updated, or deleted. You can leave all the other boxes empty.

<Admonition
  type="note"
  title="Plugin Defaults"
>

  Jira will send updates about any issues in any projects in your Jira
  installation to the webhook. We suggest that you use JQL filters to limit
  which issues are being sent to the plugin.

  The plugin's web server will run with TLS, but you can disable it with
  `--insecure-no-tls` to test things out in a dev environment.

</Admonition>

In the webhook settings page, make sure that the webhook will only send Issue
Updated updates. It's not critical if anything else gets sent, since the plugin
will just ignore everything else.

## Step 7/9. Configure the plugin

At this point, you have generated credentials that the Jira plugin will use to
connect to Teleport. You will now configure the plugin to use these credentials
to receive Access Request notifications from Teleport and post them to your Jira
project.

The Teleport email plugin uses a config file in TOML format. Generate a
boilerplate config by running the following command:

```code
$ teleport-jira configure > teleport-jira.toml
$ sudo mv teleport-jira.toml /etc
```

Edit the configuration file for your environment. We will show you how to set
each value below.

{/* TODO: Add Helm tabs for each config section*/}

### `[teleport]`

<Tabs>
<TabItem label="Teleport Enterprise" scope={["oss", "enterprise"]}>

**`addr`**: Include the hostname and HTTPS port of your Teleport Proxy Service
(e.g., `mytenant.teleport.sh:443`). If you are configuring your plugin to
connect directly to the Teleport Auth Service, use your Auth Service's gRPC
endpoint (e.g., `teleport.example.com:3025`).

**`identity`**, **`client_key`**, **`client_crt`**, **`root_cas`**: The values
you will use for these fields depend on whether the email plugin will
connect to the Proxy Service or the Auth Service. 

If you exported an identity file earlier, fill in the `identity` field with the
path to the file and comment out the other fields.

If you exported a client key, client certificate, and root CAs earlier, fill in
the `client_key`, `client_crt`, and `root_cas` fields with the paths to these
files and leave `identity` commented out.

</TabItem>
<TabItem label="Teleport Cloud" scope="cloud">

**`addr`**: Include the hostname and HTTPS port of your Teleport Cloud tenant
(e.g., `mytenant.teleport.sh:443`).

**`identity`**, **`client_key`**, **`client_crt`**, **`root_cas`**: Fill in the
`identity` field with the path to the identity file you exported earlier and
comment out the other fields.

</TabItem>
</Tabs>

### `[jira]`

Assign `url` to the URL of your Jira tenant, e.g.,
`https://[your-jira].atlassian.net"`, `username` to the user name of your Jira
bot, and `api_token` to the API token you retrieved earlier. Also assign
`project` to the project key for your project. {/* TODO: indicate how to get
the project key*/}

### `[http]`

The `[http]` setting block describes how the plugin's webhook works. 

`listen_addr` indicates the address that the plugin will listen on, and defaults
to `:8081`. If you opened 8081 on your plugin host as we recommended earlier in
the guide, you can leave this option unset.

`public_addr` is the public address of your webhook. This is the domain name you
added to the DNS A record you created earlier.

`key_file` and `cert_file` correspond to the private key and certificate you
generated earlier via Caddy. {/*TODO: Which file paths are these?*/}

The final configuration will resemble the following:

```toml
(!examples/resources/plugins/teleport-jira-self-hosted.toml!)
```
</TabItem>
<TabItem 
options="Helm Chart" 
label="Connect to the Proxy Service "
>

Create a file called `values.yaml` with the following content, which configures
the Helm chart for the plugin. It should resemble the following:

```yaml
(!examples/resources/plugins/teleport-jira-helm-cloud.yaml!)
```

Use the following command to create the Kubernetes secret referenced in the
values file from the identity file you generated earlier:

```console
kubectl create secret generic teleport-plugin-jira-identity --from-file=auth_id=auth.pem
```
</TabItem>
</Tabs>

## Step 8/9. Test the Jira plugin

After finishing your configuration, you can now run the plugin and test your
Jira-based Access Request flow:

<Tabs>
<TabItem label="Executable" scopes={["oss", "enterprise", "cloud"]}>
```code
$ teleport-jira start
```
</TabItem>
<TabItem label="Helm Chart" scopes={["oss", "enterprise", "cloud"]}>
```code
$ helm install teleport-plugin-jira teleport/teleport-plugin-jira \
  --values teleport-jira-helm.yaml \
  --version (=teleport.plugin.version=)
```
</TabItem>
</Tabs>

### Create an Access Request

(!docs/pages/includes/plugins/create-request.mdx!)

{/* TODO: Indicate what happens in Jira when you create an Access Request*/}

### Resolve the request

(!docs/pages/includes/plugins/resolve-request.mdx!)

{/* TODO: Indicate what happens in Jira when you resolve the request */}

<Admonition title="Auditing Access Requests">

When the Jira plugin posts an Access Request notification to a project, anyone
with access to the project  can view the notification and follow the link. While
users must be authorized via their Teleport roles to review Access Requests, you
should still check the Teleport audit log to ensure that the right users are
reviewing the right requests.

When auditing Access Request reviews, check for events with the type `Access
Request Reviewed` in the Teleport Web UI <ScopedBlock scope={["oss",
"enterprise"]}>and `access_request.review` if reviewing the audit log on the
Auth Service host</ScopedBlock>.

## Step 9/9. Set up systemd

In production, we recommend starting the Teleport plugin daemon via an init
system like systemd. Here's the recommended Teleport plugin service unit file
for systemd:

```txt
(!examples/systemd/plugins/teleport-jira.service!)
```

Save this as `teleport-jira.service` or another [unit file load
path](https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Unit%20File%20Load%20Path)
supported by systemd.

```code
$ sudo systemctl enable teleport-jira
$ sudo systemctl start teleport-jira
```

## Feedback

If you have any issues with this plugin, please create a GitHub issue in our
[`gravitational/teleport-plugins`](https://github.com/gravitational/teleport-plugins/issues/new)
repo.
